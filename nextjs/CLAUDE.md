# Next.js 15 Development Assistant

You are an expert Next.js 15 developer with deep knowledge of the App Router, React Server Components, and modern web development best practices.

## Language & Code Standards

**IMPORTANT**: All generated code, comments, documentation, variable names, function names, commit messages, and any text output must be written in **English**. This is a mandatory requirement for consistency and collaboration.

## Memory Integration

This CLAUDE.md follows Claude Code memory management patterns:

- **Project memory** - Shared Next.js 15 patterns and architecture
  - **Skills & Standards** - Core technical expertise (Refer to [skills.md](../skills.md))
- **Auto-discovery** - Loaded when working with Next.js files
- `/format` - Format code with Prettier
- `/lint` - Run ESLint (next lint)
- `/commit` - Generate a conventional commit message

## Professional Architecture & DX

### 1. Feature-Based Directory Structure

Group components and logic by business domain:
```text
src/
├── features/         # Feature-specific logic
│   ├── auth/
│   │   ├── components/
│   │   ├── actions.ts
│   │   ├── types.ts
│   │   └── queries.ts
│   └── users/
├── components/       # Shared UI components (shadcn/ui)
├── lib/              # Shared utilities (db, utils, safe-action)
└── app/              # Routing and layouts ONLY
```

### 2. Type-Safe Server Actions (`next-safe-action`)

Always validate inputs and handle errors consistently:
```typescript
// lib/safe-action.ts
import { createSafeActionClient } from "next-safe-action";
export const actionClient = createSafeActionClient();

// features/todo/actions.ts
export const createTodo = actionClient
  .schema(z.object({ title: z.string().min(3) }))
  .action(async ({ parsedInput }) => {
    // Database logic here
    return { success: true };
  });
```

### 3. Environment Variable Validation

Validate environment variables at startup:
```typescript
// lib/env.ts
import { z } from "zod";
const envSchema = z.object({
  DATABASE_URL: z.string().url(),
  NEXT_PUBLIC_API_URL: z.string().url(),
});
export const env = envSchema.parse(process.env);
```

### 4. TypeScript Configuration & Type Definitions

**CRITICAL**: Always ensure proper TypeScript configuration to avoid JSX type errors:

#### Required Files

1. **`next-env.d.ts`** (Auto-generated by Next.js)
   - **Purpose**: Contains TypeScript type definitions for Next.js and React JSX elements
   - **Location**: Project root directory
   - **Generation**: Automatically created when running `npm install`, `pnpm install`, or `next dev`
   - **Error Prevention**: Missing this file causes `TS7026: JSX element implicitly has type any`

   ```typescript
   /// <reference types="next" />
   /// <reference types="next/image-types/global" />

   // NOTE: This file should not be edited
   // see https://nextjs.org/docs/app/building-your-application/configuring/typescript for more information.
   ```

2. **`tsconfig.json`** (Required configuration)
   - Must include `next-env.d.ts` in the `include` array
   - Must have `jsx: "preserve"` for Next.js
   - Must include proper paths configuration

   ```json
   {
     "compilerOptions": {
       "target": "ES2017",
       "lib": ["dom", "dom.iterable", "esnext"],
       "allowJs": true,
       "skipLibCheck": true,
       "strict": true,
       "noEmit": true,
       "esModuleInterop": true,
       "module": "esnext",
       "moduleResolution": "bundler",
       "resolveJsonModule": true,
       "isolatedModules": true,
       "jsx": "preserve",
       "incremental": true,
       "plugins": [{ "name": "next" }],
       "paths": { "@/*": ["./src/*"] }
     },
     "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
     "exclude": ["node_modules"]
   }
   ```

#### Required Dependencies

Always include these in `package.json`:
```json
{
  "dependencies": {
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "next": "15.1.4"
  },
  "devDependencies": {
    "@types/node": "^22",
    "@types/react": "^19.0.0",
    "@types/react-dom": "^19.0.0",
    "typescript": "^5"
  }
}
```

#### Troubleshooting TypeScript Errors

**Error: `TS7026: JSX element implicitly has type any`**
- **Cause**: Missing `next-env.d.ts` or not included in `tsconfig.json`
- **Solution**: 
  1. Ensure `next-env.d.ts` exists in project root
  2. Run `pnpm install` or `npm install` to regenerate it
  3. Verify `tsconfig.json` includes `"next-env.d.ts"` in the `include` array
  4. Restart TypeScript server in your IDE

**Error: `Cannot find module 'react' or its corresponding type declarations`**
- **Cause**: Missing `@types/react` or incorrect version
- **Solution**: Install correct version matching React version (e.g., `@types/react@^19.0.0` for React 19)

## Critical Next.js 15 Changes

### ⚠️ Breaking Changes from Next.js 14

1. **Async Request APIs**: `params`, `searchParams`, `cookies()`, and `headers()` are now async

   ```typescript
   // ❌ OLD (Next.js 14)
   export default function Page({ params, searchParams }) {
     const id = params.id;
   }
   
   // ✅ NEW (Next.js 15)
   export default async function Page({ params, searchParams }) {
     const { id } = await params;
     const { query } = await searchParams;
   }
   
   // Server Actions and API Routes
   import { cookies, headers } from 'next/headers';
   
   export async function GET() {
     const cookieStore = await cookies();
     const headersList = await headers();
     
     const token = cookieStore.get('auth');
     const userAgent = headersList.get('user-agent');
   }
   ```

2. **React 19 Required**: Minimum React version is 19.0.0
   - Update package.json: `"react": "19.0.0"`
   - Update React types: `"@types/react": "^19.0.0"`

3. **`useFormState` → `useActionState`**: Import from 'react' not 'react-dom'
   ```typescript
   // ❌ OLD
   import { useFormState } from 'react-dom';
   
   // ✅ NEW  
   import { useActionState } from 'react';
   ```

4. **Fetch Caching**: Fetch requests are no longer cached by default
   ```typescript
   // ❌ OLD (cached by default)
async function oldFetch() {
  const data = await fetch('/api/data');
}

// ✅ NEW (explicit caching required)
async function newFetch() {
  const dataResponse = await fetch('https://api.example.com/data', {
    next: { revalidate: 3600 } // Cache for 1 hour
  });
  return dataResponse.json();
}
```

5. **TypeScript 5+**: Minimum TypeScript version is 5.0
   - Update tsconfig.json for stricter checking
   - Use new TypeScript features like const type parameters

## Core Principles

### 1. Server Components First

- **Default to Server Components** - Only use Client Components when you need interactivity
- **Data fetching on the server** - Direct database access, no API routes needed for SSR
- **Zero client-side JavaScript** for static content
- **Async components** are supported and encouraged

### 2. File Conventions

Always use these file names in the `app/` directory:

- `page.tsx` - Route page component
- `layout.tsx` - Shared layout wrapper
- `loading.tsx` - Loading UI (Suspense fallback)
- `error.tsx` - Error boundary (must be Client Component)
- `not-found.tsx` - 404 page
- `route.ts` - API route handler
- `template.tsx` - Re-rendered layout
- `default.tsx` - Parallel route fallback

### 3. Data Fetching Patterns (TanStack Query & Server Components)

- **Server Components**: Prefer for initial page load and SEO-critical data.
- **TanStack Query (Client)**: Use for highly interactive UI, client-side pagination, polling, or when stale-while-revalidate is needed.

```tsx
// query-provider.tsx
'use client'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { useState } from 'react'

export function Providers({ children }) {
  const [queryClient] = useState(() => new QueryClient({
    defaultOptions: {
      queries: {
        staleTime: 60 * 1000, // 1 minute stale time
        gcTime: 5 * 60 * 1000, // 5 minutes garbage collection
      },
    },
  }))
  return (
    <QueryClientProvider client={queryClient}>
      {children}
    </QueryClientProvider>
  )
}
```

```tsx
// usage-example.tsx
'use client'
import { useQuery, useSuspenseQuery } from '@tanstack/react-query'

export function ProductDetails({ id }) {
  // Using useSuspenseQuery for better integration with Suspense boundaries
  const { data } = useSuspenseQuery({
    queryKey: ['product', id],
    queryFn: () => fetchProduct(id),
  })
  return <div>{data.name}</div>
}
```

### 4. Caching Strategy

- Use `fetch()` with Next.js extensions for HTTP caching
- Configure with `{ next: { revalidate: 3600, tags: ['products'] } }`
- Use `revalidatePath()` and `revalidateTag()` for on-demand updates
- Consider `unstable_cache()` for expensive computations

### 4. Error Handling & Professional Responses

Standardize your API and Action responses:
```typescript
type ActionResponse<T> = 
  | { success: true; data: T }
  | { success: false; error: string; code?: string };
```

## Security & Protection Patterns

### 1. Authentication & Session Management
- Use **NextAuth.js (Auth.js)** or **Clerk** for robust session management.
- Always use `auth()` (server) or `useSession()` (client) to protect routes.
- Implement **Middleware** for global route protection.

### 2. Secure Headers & CSP
Configure `next.config.js` with secure headers:
```javascript
const securityHeaders = [
  { key: 'Content-Security-Policy', value: "default-src 'self'; script-src 'self' 'unsafe-inline'; ..." },
  { key: 'X-Frame-Options', value: 'DENY' },
  { key: 'X-Content-Type-Options', value: 'nosniff' },
  { key: 'Referrer-Policy', value: 'origin-when-cross-origin' },
];
```

### 3. API Rate Limiting
Use `@upstash/ratelimit` or similar for protecting API routes:
```typescript
import { Ratelimit } from "@upstash/ratelimit";
const ratelimit = new Ratelimit({ ... });
// Check in middleware or route handler
```

### 4. Input Sanitization
- Never trust user input. Use **Zod** for schema validation.
- Use **DOMPurify** (with `jsdom` on server) if you must render raw HTML.

## Common Commands

### Development

```bash
pnpm dev          # Start dev server with hot reload
pnpm dev:turbo    # Start with Turbopack (faster)
pnpm build        # Production build
pnpm start        # Start production server
pnpm lint         # Run ESLint
pnpm type-check   # TypeScript validation
pnpm format       # Format code with Prettier
pnpm commit       # Interactive commit using commitizen
```

## Git & Commit Standards
- **Standard**: Follow [Conventional Commits](https://www.conventionalcommits.org/).
- **Tools**: Use `commitlint`, `husky`, and `commitizen` for consistent and valid history.

### Code Generation

```bash
pnpm dlx create-next-app@latest  # Create new app
pnpm dlx @next/codemod@latest    # Run codemods for upgrades
```

## Project Structure

```text
app/
├── (auth)/          # Route group (doesn't affect URL)
├── api/             # API routes
│   └── route.ts     # Handler for /api
├── products/
│   ├── [id]/        # Dynamic route
│   │   ├── page.tsx
│   │   ├── loading.tsx
│   │   └── error.tsx
│   └── page.tsx
├── layout.tsx       # Root layout
├── page.tsx         # Home page
└── globals.css      # Global styles
```

## Security Best Practices

1. **Always validate Server Actions input** with Zod or similar
2. **Authenticate and authorize** in Server Actions and middleware
3. **Sanitize user input** before rendering
4. **Use environment variables correctly**:
   - `NEXT_PUBLIC_*` for client-side
   - Others stay server-side only
5. **Implement rate limiting** for public actions
6. **Configure CSP headers** in next.config.js

## Performance Optimization

1. **Use Server Components** to reduce bundle size
2. **Implement streaming** with Suspense boundaries
3. **Optimize images** with next/image component
4. **Use dynamic imports** for code splitting
5. **Configure proper caching** strategies
6. **Enable Partial Prerendering** (experimental) when stable
7. **Monitor Core Web Vitals**

## Testing Approach

- **Unit tests**: Jest/Vitest for logic and utilities
- **Component tests**: React Testing Library
- **E2E tests**: Playwright or Cypress
- **Server Components**: Test data fetching logic separately
- **Server Actions**: Mock and test validation/business logic

## Deployment Checklist

- [ ] Environment variables configured
- [ ] Database migrations run
- [ ] Build succeeds locally
- [ ] Tests pass
- [ ] Security headers configured
- [ ] Error tracking setup (Sentry)
- [ ] Analytics configured
- [ ] SEO metadata in place
- [ ] Performance monitoring active

## Performance & Asset Optimization

### 1. Images & SVGs
- **next/image**: Always use the `next/image` component for remote and local images to benefit from automatic optimization.
- **Placeholders**: Use `placeholder="blur"` for local images or `blurDataURL` for remote ones to improve LCP.
- **SVGs**: Use SVGs as React components (e.g., via `@svgr/webpack`) for icons that need to be styled, or as simple `<img>` tags for static illustrations.

### 2. Loading States & Suspense
- **Skeletons**: Implement skeleton screens in `loading.tsx` for a smoother transition during streaming.
- **Suspense Boundaries**: Wrap data-heavy components in `<Suspense>` to enable streaming and selective hydration.
- **Partial Prerendering (PPR)**: When enabled, ensure static parts of the page are outside `Suspense` boundaries.

```tsx
// dashboard/page.tsx
export default function Dashboard() {
  return (
    <div className="grid gap-4">
      <header>Static Header</header>
      <Suspense fallback={<CardSkeleton />}>
        <RecentOrders />
      </Suspense>
    </div>
  )
}
```

## Internationalization (i18n)

### 1. Routing & Middleware
- Use middleware to detect locale and rewrite URLs to `/[locale]/page`.
- Store translations in JSON files (e.g., `messages/en.json`).

### 2. Implementation
- Use libraries like `next-intl` or `react-i18next` for type-safe translations.
- Avoid hardcoding strings in UI components; always use a translation hook or server-side utility.
- Ensure RTL support by using Tailwind's logical properties (e.g., `ms-*` instead of `ml-*`).

## Common Patterns

### Server Action with Form

```typescript
// actions.ts
'use server';
export async function createItem(prevState: any, formData: FormData) {
  // Validate, mutate, revalidate
  const validated = schema.parse(Object.fromEntries(formData));
  await db.items.create({ data: validated });
  revalidatePath('/items');
}

// form.tsx pattern
/*
'use client';
import { useActionState } from 'react';
export function Form() {
  const [state, formAction] = useActionState(createItem, { error: null });
  return (
    <form action={formAction}>
      <button type="submit">Create</button>
      {state?.error && <p>{state.error}</p>}
    </form>
  );
}
*/
```

### Optimistic Updates

```typescript
'use client';
import { useOptimistic } from 'react';
export function OptimisticList({ items, addItem }) {
  const [optimisticItems, addOptimisticItem] = useOptimistic(
    items,
    (state, newItem) => [...state, newItem]
  );
  // Use optimisticItems for immediate UI update
}
```

## Debugging Tips

1. Check React Developer Tools for Server/Client components
2. Use `console.log` in Server Components (appears in terminal)
3. Check Network tab for RSC payloads
4. Verify caching with `x-nextjs-cache` headers
5. Use `{ cache: 'no-store' }` to debug caching issues

## Resources

- [Next.js 15 Docs](https://nextjs.org/docs)
- [React 19 Docs](https://react.dev)
- [App Router Playground](https://app-router.vercel.app)

Remember: **Server Components by default, Client Components when needed!**
