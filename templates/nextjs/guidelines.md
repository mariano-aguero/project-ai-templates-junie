# Next.js 16 Development Guidelines

Guidelines for building Next.js 16 applications with App Router, React 19, Server Components, and modern web development best practices.

## Language & Code Standards

**MANDATORY**: All code, comments, documentation, variable names, function names, and commit messages must be in **English**.

## Core Principles

### 1. Server Components First
- **Default to Server Components** - Only use Client Components when you need interactivity
- **Data fetching on the server** - Direct database access, no API routes needed for SSR
- **Zero client-side JavaScript** for static content
- **Async components** are supported and encouraged

### 2. File Conventions

Always use these file names in the `app/` directory:
- `page.tsx` - Route page component
- `layout.tsx` - Shared layout wrapper
- `loading.tsx` - Loading UI (Suspense fallback)
- `error.tsx` - Error boundary (must be Client Component)
- `not-found.tsx` - 404 page
- `route.ts` - API route handler
- `template.tsx` - Re-rendered layout
- `default.tsx` - Parallel route fallback

## Professional Architecture

### 1. Feature-Based Directory Structure

Group components and logic by business domain:
```text
src/
├── features/         # Feature-specific logic
│   ├── auth/
│   │   ├── components/
│   │   ├── actions.ts
│   │   ├── types.ts
│   │   └── queries.ts
│   └── users/
├── components/       # Shared UI components (shadcn/ui)
├── lib/              # Shared utilities (db, utils, safe-action)
└── app/              # Routing and layouts ONLY
```

### 2. Type-Safe Server Actions

Always validate inputs and handle errors consistently:
```typescript
// lib/safe-action.ts
import { createSafeActionClient } from "next-safe-action";
export const actionClient = createSafeActionClient();

// features/todo/actions.ts
export const createTodo = actionClient
  .schema(z.object({ title: z.string().min(3) }))
  .action(async ({ parsedInput }) => {
    // Database logic here
    return { success: true };
  });
```

### 3. Environment Variable Validation

Validate environment variables at startup:
```typescript
// lib/env.ts
import { z } from "zod";
const envSchema = z.object({
  DATABASE_URL: z.string().url(),
  NEXT_PUBLIC_API_URL: z.string().url(),
});
export const env = envSchema.parse(process.env);
```

### 4. TypeScript Configuration & Type Definitions

**CRITICAL**: Always ensure proper TypeScript configuration to avoid JSX type errors.

#### Required Files

1. **`next-env.d.ts`** (Auto-generated by Next.js)
   - Contains TypeScript type definitions for Next.js and React JSX elements
   - Location: Project root directory
   - Generation: Automatically created when running `npm install`, `pnpm install`, or `next dev`
   - Missing this file causes `TS7026: JSX element implicitly has type any`

2. **`tsconfig.json`** (Required configuration)
   - Must include `next-env.d.ts` in the `include` array
   - Must have `jsx: "preserve"` for Next.js
   - Must include proper paths configuration

```json
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [{ "name": "next" }],
    "paths": { "@/*": ["./src/*"] }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
```

#### Required Dependencies

```json
{
  "dependencies": {
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "next": "16.0.0"
  },
  "devDependencies": {
    "@types/node": "^22",
    "@types/react": "^19.0.0",
    "@types/react-dom": "^19.0.0",
    "typescript": "^5"
  }
}
```

#### Troubleshooting TypeScript Errors

**Error: `TS7026: JSX element implicitly has type any`**
- Cause: Missing `next-env.d.ts` or not included in `tsconfig.json`
- Solution: 
  1. Ensure `next-env.d.ts` exists in project root
  2. Run `pnpm install` or `npm install` to regenerate it
  3. Verify `tsconfig.json` includes `"next-env.d.ts"` in the `include` array
  4. Restart TypeScript server in your IDE

**Error: `Cannot find module 'react' or its corresponding type declarations`**
- Cause: Missing `@types/react` or incorrect version
- Solution: Install correct version matching React version (e.g., `@types/react@^19.0.0` for React 19)

## Critical Next.js 16 Changes

### Breaking Changes from Next.js 14

1. **Async Request APIs**: `params`, `searchParams`, `cookies()`, and `headers()` are now async

```typescript
// ❌ OLD (Next.js 14)
export default function Page({ params, searchParams }) {
  const id = params.id;
}

// ✅ NEW (Next.js 16)
export default async function Page({ params, searchParams }) {
  const { id } = await params;
  const { query } = await searchParams;
}

// Server Actions and API Routes
import { cookies, headers } from 'next/headers';

export async function GET() {
  const cookieStore = await cookies();
  const headersList = await headers();
  
  const token = cookieStore.get('auth');
  const userAgent = headersList.get('user-agent');
}
```

2. **React 19 Required**: Minimum React version is 19.0.0
   - Update package.json: `"react": "19.0.0"`
   - Update React types: `"@types/react": "^19.0.0"`

3. **`useFormState` → `useActionState`**: Import from 'react' not 'react-dom'
```typescript
// ❌ OLD
import { useFormState } from 'react-dom';

// ✅ NEW  
import { useActionState } from 'react';
```

4. **Fetch Caching**: Fetch requests are no longer cached by default
```typescript
// ❌ OLD (cached by default)
async function oldFetch() {
  const data = await fetch('/api/data');
}

// ✅ NEW (explicit caching required)
async function newFetch() {
  const dataResponse = await fetch('https://api.example.com/data', {
    next: { revalidate: 3600 } // Cache for 1 hour
  });
  return dataResponse.json();
}
```

5. **TypeScript 5+**: Minimum TypeScript version is 5.0

## Data Fetching Patterns

### Server Components vs TanStack Query

- **Server Components**: Prefer for initial page load and SEO-critical data
- **TanStack Query (Client)**: Use for highly interactive UI, client-side pagination, polling, or when stale-while-revalidate is needed

```tsx
// query-provider.tsx
'use client'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { useState } from 'react'

export function Providers({ children }) {
  const [queryClient] = useState(() => new QueryClient({
    defaultOptions: {
      queries: {
        staleTime: 60 * 1000, // 1 minute stale time
        gcTime: 5 * 60 * 1000, // 5 minutes garbage collection
      },
    },
  }))
  return (
    <QueryClientProvider client={queryClient}>
      {children}
    </QueryClientProvider>
  )
}
```

```tsx
// usage-example.tsx
'use client'
import { useQuery, useSuspenseQuery } from '@tanstack/react-query'

export function ProductDetails({ id }) {
  // Using useSuspenseQuery for better integration with Suspense boundaries
  const { data } = useSuspenseQuery({
    queryKey: ['product', id],
    queryFn: () => fetchProduct(id),
  })
  return <div>{data.name}</div>
}
```

### Caching Strategy

- Use `fetch()` with Next.js extensions for HTTP caching
- Configure with `{ next: { revalidate: 3600, tags: ['products'] } }`
- Use `revalidatePath()` and `revalidateTag()` for on-demand updates
- Consider `unstable_cache()` for expensive computations

### Error Handling & Professional Responses

Standardize your API and Action responses:
```typescript
type ActionResponse<T> = 
  | { success: true; data: T }
  | { success: false; error: string; code?: string };
```

## Security Best Practices

1. **Always validate Server Actions input** with Zod or similar
2. **Authenticate and authorize** in Server Actions and middleware
3. **Sanitize user input** before rendering
4. **Use environment variables correctly**:
   - `NEXT_PUBLIC_*` for client-side
   - Others stay server-side only
5. **Implement rate limiting** for public actions
6. **Configure CSP headers** in next.config.js

### Secure Headers & CSP

Configure `next.config.js` with secure headers:
```javascript
const securityHeaders = [
  { key: 'Content-Security-Policy', value: "default-src 'self'; script-src 'self' 'unsafe-inline'; ..." },
  { key: 'X-Frame-Options', value: 'DENY' },
  { key: 'X-Content-Type-Options', value: 'nosniff' },
  { key: 'Referrer-Policy', value: 'origin-when-cross-origin' },
];
```

### API Rate Limiting

Use `@upstash/ratelimit` or similar for protecting API routes:
```typescript
import { Ratelimit } from "@upstash/ratelimit";
const ratelimit = new Ratelimit({ ... });
// Check in middleware or route handler
```

### Input Sanitization

- Never trust user input. Use **Zod** for schema validation
- Use **DOMPurify** (with `jsdom` on server) if you must render raw HTML

## Performance Optimization

1. **Use Server Components** to reduce bundle size
2. **Implement streaming** with Suspense boundaries
3. **Optimize images** with next/image component
4. **Use dynamic imports** for code splitting
5. **Configure proper caching** strategies
6. **Enable Partial Prerendering** (experimental) when stable
7. **Monitor Core Web Vitals**

### Images & Loading States

- **next/image**: Always use for automatic optimization
- **Placeholders**: Use `placeholder="blur"` for local images or `blurDataURL` for remote ones
- **Skeletons**: Implement skeleton screens in `loading.tsx`
- **Suspense Boundaries**: Wrap data-heavy components in `<Suspense>` to enable streaming

```tsx
// dashboard/page.tsx
export default function Dashboard() {
  return (
    <div className="grid gap-4">
      <header>Static Header</header>
      <Suspense fallback={<CardSkeleton />}>
        <RecentOrders />
      </Suspense>
    </div>
  )
}
```

## Common Patterns

### Server Action with Form

```typescript
// actions.ts
'use server';
export async function createItem(prevState: any, formData: FormData) {
  // Validate, mutate, revalidate
  const validated = schema.parse(Object.fromEntries(formData));
  await db.items.create({ data: validated });
  revalidatePath('/items');
}

// form.tsx
'use client';
import { useActionState } from 'react';

export function Form() {
  const [state, formAction] = useActionState(createItem, { error: null });
  return (
    <form action={formAction}>
      <button type="submit">Create</button>
      {state?.error && <p>{state.error}</p>}
    </form>
  );
}
```

### Optimistic Updates

```typescript
'use client';
import { useOptimistic } from 'react';
export function OptimisticList({ items, addItem }) {
  const [optimisticItems, addOptimisticItem] = useOptimistic(
    items,
    (state, newItem) => [...state, newItem]
  );
  // Use optimisticItems for immediate UI update
}
```

## Testing Approach

- **Unit tests**: Jest/Vitest for logic and utilities
- **Component tests**: React Testing Library
- **E2E tests**: Playwright or Cypress
- **Server Components**: Test data fetching logic separately
- **Server Actions**: Mock and test validation/business logic

## Deployment Checklist

- [ ] Environment variables configured
- [ ] Database migrations run
- [ ] Build succeeds locally
- [ ] Tests pass
- [ ] Security headers configured
- [ ] Error tracking setup (Sentry)
- [ ] Analytics configured
- [ ] SEO metadata in place
- [ ] Performance monitoring active

## Resources

- [Next.js 16 Docs](https://nextjs.org/docs)
- [React 19 Docs](https://react.dev)
- [App Router Playground](https://app-router.vercel.app)

---

**Remember: Server Components by default, Client Components when needed!**
